1. 全局作用域。这个没啥说的，就是在顶层环境中申明的变量都是全局作用域，他们的属性其实都在 window 对象下面。

2. 函数作用域。在函数内部定义的变量都是函数作用域，只能在函数中访问到，当然也可以通过闭包来访问。除此之外，在其他地方是没法访问函数内部的变量的。

3. 局部作用域。es6 中新增的特性，弥补了以前只能使用匿名及时运行函数来创建局部变量的缺陷。使用很简单，直接用 let 来申明变量就行。也可以使用 const 来申明变量，表明这是常数。
   作用域链。要说清这个，需要首先明白 javascript 的代码运行过程。假设现在有个函数 funcA，在该函数内部申明了一个局部变量 a，在函数内部又定义了一个函数 funcB，在函数 B 中申明了变量 b。如下：
   function funcA () {
   let a;
   function funcB () {
   let b;
   }
   }
   当进入 funcA 时，这时候会把变量 a 压入当前的作用域 A 中，并且将作用域 A 入栈，当进入 funcB 时，则会把变量 b 压入当前的作用域 B 中，并且将作用域 B 入栈，那么这时候栈中就有了作用域 A 和作用域 B，当在 funcB 中查找某个变量时，会先从当前的作用域 B 中查找，如果没有的话，那么就根据栈中的作用域依次往上查找，这就是作用域链。
4. 闭包是什么，什么时候闭包会消除?

因为作用域链，外部不能访问内部的变量和方法，这时我们就需要通过闭包，返回内部的方法和变量给外部，从而就形成了一个闭包。

JavaScript 是一门具有自动垃圾回收机制的编程语言，主要有两种方式：

1. 标记清除（最常用）
   垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

2. 引用计数
   引用计数（reference counting）的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。

导致问题：会导致循环引用的变量和函数无法回收。

解决：将用完的函数或者变量置为 null。

js 变量回收规则

1. 在 js 中定义的全局变量是不会被销毁的，因为随时都可能会用到这个变量，所以不能被销毁。
2. 具体引用关系的不会被销毁
   如果一个对象不被引用，那么这个对象就会被回收；
   如果两个对象互相引用，但是没有被第 3 个对象所引用，那么这两个互相引用的对象也会被回收。
